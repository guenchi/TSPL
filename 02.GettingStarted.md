### 第2章 入门

本章是为刚接触Scheme语言的程序员准备的入门介绍。如果你坐在一个交互式的Scheme系统前，边阅读边尝试示例，你会从本章中获得更多。

在阅读本章并完成练习后，你应该能够开始使用Scheme。你将学习Scheme程序的语法及其执行方式，以及如何使用简单的数据结构和控制机制。

#### 2.1 与Scheme交互

大多数Scheme系统提供了一个交互式编程环境，简化了程序开发和实验。与Scheme的最简单交互遵循“读取-求值-打印”循环。一个程序（通常称为读取-求值-打印循环，或REPL）读取你从键盘输入的每个表达式，求值并打印其结果。

通过交互式Scheme系统，你可以在键盘上输入一个表达式并立即看到其值。你可以定义一个过程并将其应用于参数，看看它是如何工作的。你甚至可以输入一个由一组过程定义组成的完整程序，并在不离开系统的情况下进行测试。当你的程序开始变长时，将其输入到文件中（使用文本编辑器），加载文件并交互式测试会更加方便。在大多数Scheme系统中，可以使用非标准过程`load`加载文件，该过程接受一个字符串参数作为文件名。将程序准备在文件中有几个优点：你可以更仔细地编写程序，可以在不重新输入程序的情况下纠正错误，并且可以保留副本以备后用。大多数Scheme实现将文件中加载的表达式与从键盘输入的表达式同等对待。

尽管Scheme提供了各种输入和输出过程，但REPL负责读取表达式并打印其值。这使你能够专注于编写程序，而不必担心如何显示其结果。

本章及本书其余部分的示例遵循一种常规格式。你可能会从键盘输入的表达式首先给出，可能跨越多行。表达式的值在`<graphic>`之后给出，读作“求值为”。对于定义和当表达式的值未指定时，省略`<graphic>`。

示例程序的格式风格“看起来不错”，并传达了程序的结构。代码易于阅读，因为每个表达式与其子表达式之间的关系清晰可见。然而，Scheme忽略缩进和换行符，因此不需要遵循特定的风格。重要的是建立一种风格并保持一致。Scheme将每个程序视为单行，其子表达式从左到右排序。

如果你可以访问一个交互式Scheme系统，现在启动它并在阅读时输入示例可能是个好主意。最简单的Scheme表达式之一是字符串常量。尝试在提示符后输入`"Hi Mom!"`（包括双引号）。系统应响应`"Hi Mom!"`；任何常量的值都是常量本身。

```scheme
"Hi Mom!" <graphic> "Hi Mom!"
```

以下是一组表达式，每个表达式都有Scheme的响应。它们将在本章后面的部分中解释，但现在可以用它们来练习与Scheme的交互。

```scheme
"hello" <graphic> "hello"
42 <graphic> 42
22/7 <graphic> 22/7
3.141592653 <graphic> 3.141592653
+ <graphic> #<procedure>
(+ 76 31) <graphic> 107
(* -12 10) <graphic> -120
'(a b c d) <graphic> (a b c d)
```

小心不要遗漏任何单引号（`'`）、双引号或括号。如果你在最后一个表达式中遗漏了单引号，你可能会收到一条消息，指示发生了异常。只需再试一次。如果你遗漏了右括号或双引号，系统可能仍在等待它。

以下是更多可以尝试的表达式。你可以尝试自己弄清楚它们的含义，或者等到本章后面再了解。

```scheme
(car '(a b c)) <graphic> a
(cdr '(a b c)) <graphic> (b c)
(cons 'a '(b c)) <graphic> (a b c)
(cons (car '(a b c))
      (cdr '(d e f))) <graphic> (a e f)
```

如你所见，Scheme表达式可以跨越多行。Scheme系统通过匹配双引号和括号知道何时拥有整个表达式。

接下来，让我们尝试定义一个过程。

```scheme
(define square
  (lambda (n)
    (* n n)))
```

过程`square`计算任何数字`n`的平方`n²`。我们将在本章后面详细讨论构成此定义的表达式。现在只需知道`define`建立变量绑定，`lambda`创建过程，`*`表示乘法过程。注意这些表达式的形式。所有结构化形式都用括号括起来，并以前缀表示法编写，即运算符在参数之前。如你所见，即使是简单的算术操作如`*`也是如此。

尝试使用`square`。

```scheme
(square 5) <graphic> 25
(square -200) <graphic> 40000
(square 0.5) <graphic> 0.25
(square -1/2) <graphic> 1/4
```

尽管下一个定义很短，你可能会将其输入到文件中。假设你将该文件命名为`"reciprocal.ss"`。

```scheme
(define reciprocal
  (lambda (n)
    (if (= n 0)
        "oops!"
        (/ 1 n))))
```

这个过程`reciprocal`计算任何数字`n ≠ 0`的`1/n`。对于`n = 0`，`reciprocal`返回字符串`"oops!"`。返回Scheme并尝试使用过程`load`加载你的文件。

```scheme
(load "reciprocal.ss")
```

最后，尝试使用我们刚刚定义的过程。

```scheme
(reciprocal 10) <graphic> 1/10
(reciprocal 1/10) <graphic> 10
(reciprocal 0) <graphic> "oops!"
(reciprocal (reciprocal 1/10)) <graphic> 1/10
```

在下一节中，我们将更详细地讨论Scheme表达式。在本章中，请记住你的Scheme系统是学习Scheme最有用的工具之一。每当你尝试文本中的一个示例时，请用自己的示例跟进。在交互式Scheme系统中，尝试某些东西的成本相对较低——通常只需输入时间。

#### 2.2 简单表达式

最简单的Scheme表达式是常量数据对象，如字符串、数字、符号和列表。Scheme支持其他对象类型，但这四种足以满足许多程序的需求。我们在上一节中看到了一些字符串和数字的示例。

让我们更详细地讨论数字。数字是常量。如果你输入一个数字，Scheme会将其回显给你。以下示例显示Scheme支持几种类型的数字。

```scheme
123456789987654321 <graphic> 123456789987654321
3/4 <graphic> 3/4
2.718281828 <graphic> 2.718281828
2.2+1.1i <graphic> 2.2+1.1i
```

Scheme数字包括精确和不精确的整数、有理数、实数和复数。精确整数和有理数具有任意精度，即它们可以是任意大小。不精确数通常使用IEEE标准浮点表示法在内部表示。

Scheme为相应的算术过程提供了名称`+`、`-`、`*`和`/`。每个过程接受两个数字参数。以下表达式称为过程应用，因为它们指定了将过程应用于一组参数。

```scheme
(+ 1/2 1/2) <graphic> 1
(- 1.5 1/2) <graphic> 1.0
(* 3 1/2) <graphic> 3/2
(/ 1.5 3/4) <graphic> 2.0
```

Scheme对常见算术操作也使用前缀表示法。任何过程应用，无论过程接受零个、一个、两个还是更多参数，都写为`(procedure arg ...)`。这种规律性简化了表达式的语法；无论操作如何，都使用一种表示法，并且没有关于运算符优先级或结合性的复杂规则。

过程应用可以嵌套，在这种情况下，最内层的值首先计算。因此，我们可以嵌套上述算术过程的应用来评估更复杂的公式。

```scheme
(+ (+ 2 2) (+ 2 2)) <graphic> 8
(- 2 (* 4 1/3)) <graphic> 2/3
(* 2 (* 2 (* 2 (* 2 2)))) <graphic> 32
(/ (* 6/7 7/2) (- 4.5 1.5)) <graphic> 1.0
```

这些示例展示了使用Scheme作为四功能桌面计算器所需的一切。虽然我们不会在本章讨论它们，但Scheme支持许多其他算术过程。现在可能是转到第6.4节并尝试其中一些的好时机。

简单的数字对象足以满足许多任务，但有时需要包含两个或多个值的聚合数据结构。在许多语言中，基本的聚合数据结构是数组。在Scheme中，它是列表。列表写为由对象组成的序列，用括号括起来。例如，`(1 2 3 4 5)`是一个数字列表，`("this" "is" "a" "list")`是一个字符串列表。列表不必只包含一种类型的对象，因此`(4.2 "hi")`是一个包含数字和字符串的有效列表。列表可以嵌套（可以包含其他列表），因此`((1 2) (3 4))`是一个具有两个元素的有效列表，每个元素都是一个包含两个元素的列表。

你可能会注意到列表看起来像过程应用，并想知道Scheme如何区分它们。也就是说，Scheme如何区分对象列表`(obj1 obj2 ...)`和过程应用`(procedure arg ...)`？

在某些情况下，区别可能看起来很明显。数字列表`(1 2 3 4 5)`几乎不可能与过程应用混淆，因为`1`是一个数字，而不是一个过程。因此，答案可能是Scheme查看列表或过程应用的第一个元素，并根据该第一个元素是否是过程做出决定。这个答案不够好，因为我们甚至可能希望将有效的过程应用如`(+ 3 4)`视为列表。答案是，我们必须明确告诉Scheme将列表视为数据而不是过程应用。我们使用`quote`来实现这一点。

```scheme
(quote (1 2 3 4 5)) <graphic> (1 2 3 4 5)
(quote ("this" "is" "a" "list")) <graphic> ("this" "is" "a" "list")
(quote (+ 3 4)) <graphme> (+ 3 4)
```

`quote`强制将列表视为数据。尝试输入上述表达式而不使用`quote`；你可能会收到一条消息，指示前两个表达式发生了异常，第三个表达式返回了错误的答案（7）。

由于`quote`在Scheme代码中经常使用，Scheme将表达式前的单引号（`'`）视为`quote`的缩写。

```scheme
'(1 2 3 4) <graphic> (1 2 3 4)
'((1 2) (3 4)) <graphic> ((1 2) (3 4))
'(/ (* 2 -1) 3) <graphic> (/ (* 2 -1) 3)
```

这两种形式都称为`quote`表达式。我们通常说一个对象在`quote`表达式中被引用。

`quote`表达式不是过程应用，因为它禁止对其子表达式求值。它是一种完全不同的语法形式。Scheme除了过程应用和`quote`表达式外，还支持其他几种语法形式。每种语法形式的求值方式不同。幸运的是，不同语法形式的数量很少。我们将在本章后面看到更多。

并非所有`quote`表达式都涉及列表。尝试以下表达式，带和不带`quote`包装。

```scheme
(quote hello) <graphic> hello
```

符号`hello`必须被引用，以防止Scheme将`hello`视为变量。Scheme中的符号和变量类似于数学表达式和方程中的符号和变量。当我们评估数学表达式`1 - x`时，我们将`x`视为变量。另一方面，当我们考虑代数方程`x² - 1 = (x - 1)(x + 1)`时，我们将`x`视为符号（实际上，我们将整个方程视为符号）。正如引用列表告诉Scheme将括号形式视为列表而不是过程应用一样，引用标识符告诉Scheme将标识符视为符号而不是变量。虽然符号通常用于表示方程或程序的符号表示中的变量，但符号也可以用于表示自然语言句子中的单词。

你可能会想知道为什么应用和变量与列表和符号共享表示法。共享表示法允许Scheme程序表示为Scheme数据，简化了在Scheme中编写解释器、编译器、编辑器和其他工具的过程。这在第12.7节中给出的Scheme解释器中得到了证明，该解释器本身是用Scheme编写的。许多人认为这是Scheme最重要的特性之一。

数字和字符串也可以被引用。

```scheme
'2 <graphic> 2
'2/3 <graphic> 2/3
(quote "Hi Mom!") <graphic> "Hi Mom!"
```

然而，数字和字符串在任何情况下都被视为常量，因此引用它们是不必要的。

现在让我们讨论一些用于操作列表的Scheme过程。有两个基本过程用于分解列表：`car`和`cdr`（发音为“could-er”）。`car`返回列表的第一个元素，`cdr`返回列表的其余部分。（名称“car”和“cdr”源自第一个实现Lisp语言的计算机IBM 704支持的操作。）每个过程都需要一个非空列表作为其参数。

```scheme
(car '(a b c)) <graphic> a
(cdr '(a b c)) <graphic> (b c)
(cdr '(a)) <graphic> ()
(car (cdr '(a b c))) <graphic> b
(cdr (cdr '(a b c))) <graphic> (c)
(car '((a b) (c d))) <graphic> (a b)
(cdr '((a b) (c d))) <graphic> ((c d))
```

列表的第一个元素通常称为列表的“car”，列表的其余部分通常称为列表的“cdr”。具有一个元素的列表的`cdr`是`()`，即空列表。

过程`cons`构造列表。它接受两个参数。第二个参数通常是一个列表，在这种情况下，`cons`返回一个列表。

```scheme
(cons 'a '()) <graphic> (a)
(cons 'a '(b c)) <graphic> (a b c)
(cons 'a (cons 'b (cons 'c '()))) <graphic> (a b c)
(cons '(a b) '(c d)) <graphic> ((a b) c d)
(car (cons 'a '(b c))) <graphic> a
(cdr (cons 'a '(b c))) <graphic> (b c)
(cons (car '(a b c))
      (cdr '(d e f))) <graphic> (a e f)
(cons (car '(a b c))
      (cdr '(a b c))) <graphic> (a b c)
```

正如“car”和“cdr”通常用作名词一样，“cons”通常用作动词。通过将元素添加到列表的开头来创建新列表称为将元素“cons”到列表中。

注意`cons`的第二个参数描述中的“通常”一词。过程`cons`实际上构建对，并且对的`cdr`不必是列表。列表是一系列对；每对的`cdr`是序列中的下一对。

```graphic
```

正确列表中的最后一对的`cdr`是空列表。否则，对序列形成一个不正确的列表。更正式地说，空列表是一个正确的列表，任何`cdr`是正确列表的对也是一个正确的列表。

不正确列表以点对表示法打印，点号（`.`）位于列表的最后一个元素之前。

```scheme
(cons 'a 'b) <graphic> (a . b)
(cdr '(a . b)) <graphic> b
(cons 'a '(b . c)) <graphic> (a b . c)
```

由于其打印表示法，`cdr`不是列表的对通常称为点对。即使`cdr`是列表的对也可以用点对表示法编写，尽管打印机总是选择不带点地编写正确列表。

```scheme
'(a . (b . (c . ()))) <graphic> (a b c)
```

过程`list`类似于`cons`，只是它接受任意数量的参数并始终构建一个正确列表。

```scheme
(list 'a 'b 'c) <graphic> (a b c)
(list 'a) <graphic> (a)
(list) <graphic> ()
```

第6.3节提供了更多关于列表和Scheme操作列表的过程的信息。现在可能是转到该部分并熟悉其中给出的其他过程的好时机。

#### 练习 2.2.1

将以下算术表达式转换为Scheme表达式并求值。

a. 1.2 × (2 - 1/3) + -8.7  
b. (2/3 + 4/9) ÷ (5/11 - 4/3)  
c. 1 + 1 ÷ (2 + 1 ÷ (1 + 1/2))  
d. 1 × -2 × 3 × -4 × 5 × -6 × 7  

#### 练习 2.2.2

尝试使用过程`+`、`-`、`*`和`/`来确定Scheme在给定不同类型数字参数时返回的值的类型规则。

#### 练习 2.2.3

确定以下表达式的值。使用你的Scheme系统验证你的答案。

a. `(cons 'car 'cdr)`  
b. `(list 'this '(is silly))`  
c. `(cons 'is '(this silly?))`  
d. `(quote (+ 2 3))`  
e. `(cons '+ '(2 3))`  
f. `(car '(+ 2 3))`  
g. `(cdr '(+ 2 3))`  
h. `cons`  
i. `(quote cons)`  
j. `(quote (quote cons))`  
k. `(car (quote (quote cons)))`  
l. `(+ 2 3)`  
m. `(+ '2 '3)`  
n. `(+ (car '(2 3)) (car (cdr '(2 3))))`  
o. `((car (list + - * /)) 2 3)`  

#### 练习 2.2.4

`(car (car '((a b) (c d))))`返回`a`。确定应用于`((a b) (c d))`的`car`和`cdr`的组合，返回`b`、`c`和`d`。

#### 练习 2.2.5

编写一个Scheme表达式，求值为以下内部列表结构。

```graphic
```

#### 练习 2.2.6

绘制以下表达式生成的内部列表结构。

```scheme
(cons 1 (cons '(2 . ((3
