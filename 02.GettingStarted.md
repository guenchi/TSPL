### 第2章 入门

本章是为刚接触Scheme语言的程序员准备的入门介绍。如果你坐在一个交互式的Scheme系统前，边阅读边尝试示例，你会从本章中获得更多。

在阅读本章并完成练习后，你应该能够开始使用Scheme。你将学习Scheme程序的语法及其执行方式，以及如何使用简单的数据结构和控制机制。

#### 2.1 与Scheme交互

大多数Scheme系统提供了一个交互式编程环境，简化了程序开发和实验。与Scheme的最简单交互遵循“读取-求值-打印”循环。一个程序（通常称为读取-求值-打印循环，或REPL）读取你从键盘输入的每个表达式，求值并打印其结果。

通过交互式Scheme系统，你可以在键盘上输入一个表达式并立即看到其值。你可以定义一个过程并将其应用于参数，看看它是如何工作的。你甚至可以输入一个由一组过程定义组成的完整程序，并在不离开系统的情况下进行测试。当你的程序开始变长时，将其输入到文件中（使用文本编辑器），加载文件并交互式测试会更加方便。在大多数Scheme系统中，可以使用非标准过程`load`加载文件，该过程接受一个字符串参数作为文件名。将程序准备在文件中有几个优点：你可以更仔细地编写程序，可以在不重新输入程序的情况下纠正错误，并且可以保留副本以备后用。大多数Scheme实现将文件中加载的表达式与从键盘输入的表达式同等对待。

尽管Scheme提供了各种输入和输出过程，但REPL负责读取表达式并打印其值。这使你能够专注于编写程序，而不必担心如何显示其结果。

本章及本书其余部分的示例遵循一种常规格式。你可能会从键盘输入的表达式首先给出，可能跨越多行。表达式的值在`<graphic>`之后给出，读作“求值为”。对于定义和当表达式的值未指定时，省略`<graphic>`。

示例程序的格式风格“看起来不错”，并传达了程序的结构。代码易于阅读，因为每个表达式与其子表达式之间的关系清晰可见。然而，Scheme忽略缩进和换行符，因此不需要遵循特定的风格。重要的是建立一种风格并保持一致。Scheme将每个程序视为单行，其子表达式从左到右排序。

如果你可以访问一个交互式Scheme系统，现在启动它并在阅读时输入示例可能是个好主意。最简单的Scheme表达式之一是字符串常量。尝试在提示符后输入`"Hi Mom!"`（包括双引号）。系统应响应`"Hi Mom!"`；任何常量的值都是常量本身。

```scheme
"Hi Mom!" <graphic> "Hi Mom!"
```

以下是一组表达式，每个表达式都有Scheme的响应。它们将在本章后面的部分中解释，但现在可以用它们来练习与Scheme的交互。

```scheme
"hello" <graphic> "hello"
42 <graphic> 42
22/7 <graphic> 22/7
3.141592653 <graphic> 3.141592653
+ <graphic> #<procedure>
(+ 76 31) <graphic> 107
(* -12 10) <graphic> -120
'(a b c d) <graphic> (a b c d)
```

小心不要遗漏任何单引号（`'`）、双引号或括号。如果你在最后一个表达式中遗漏了单引号，你可能会收到一条消息，指示发生了异常。只需再试一次。如果你遗漏了右括号或双引号，系统可能仍在等待它。

以下是更多可以尝试的表达式。你可以尝试自己弄清楚它们的含义，或者等到本章后面再了解。

```scheme
(car '(a b c)) <graphic> a
(cdr '(a b c)) <graphic> (b c)
(cons 'a '(b c)) <graphic> (a b c)
(cons (car '(a b c))
      (cdr '(d e f))) <graphic> (a e f)
```

如你所见，Scheme表达式可以跨越多行。Scheme系统通过匹配双引号和括号知道何时拥有整个表达式。

接下来，让我们尝试定义一个过程。

```scheme
(define square
  (lambda (n)
    (* n n)))
```

过程`square`计算任何数字`n`的平方`n²`。我们将在本章后面详细讨论构成此定义的表达式。现在只需知道`define`建立变量绑定，`lambda`创建过程，`*`表示乘法过程。注意这些表达式的形式。所有结构化形式都用括号括起来，并以前缀表示法编写，即运算符在参数之前。如你所见，即使是简单的算术操作如`*`也是如此。

尝试使用`square`。

```scheme
(square 5) <graphic> 25
(square -200) <graphic> 40000
(square 0.5) <graphic> 0.25
(square -1/2) <graphic> 1/4
```

尽管下一个定义很短，你可能会将其输入到文件中。假设你将该文件命名为`"reciprocal.ss"`。

```scheme
(define reciprocal
  (lambda (n)
    (if (= n 0)
        "oops!"
        (/ 1 n))))
```

这个过程`reciprocal`计算任何数字`n ≠ 0`的`1/n`。对于`n = 0`，`reciprocal`返回字符串`"oops!"`。返回Scheme并尝试使用过程`load`加载你的文件。

```scheme
(load "reciprocal.ss")
```

最后，尝试使用我们刚刚定义的过程。

```scheme
(reciprocal 10) <graphic> 1/10
(reciprocal 1/10) <graphic> 10
(reciprocal 0) <graphic> "oops!"
(reciprocal (reciprocal 1/10)) <graphic> 1/10
```

在下一节中，我们将更详细地讨论Scheme表达式。在本章中，请记住你的Scheme系统是学习Scheme最有用的工具之一。每当你尝试文本中的一个示例时，请用自己的示例跟进。在交互式Scheme系统中，尝试某些东西的成本相对较低——通常只需输入时间。

#### 2.2 简单表达式

最简单的Scheme表达式是常量数据对象，如字符串、数字、符号和列表。Scheme支持其他对象类型，但这四种足以满足许多程序的需求。我们在上一节中看到了一些字符串和数字的示例。

让我们更详细地讨论数字。数字是常量。如果你输入一个数字，Scheme会将其回显给你。以下示例显示Scheme支持几种类型的数字。

```scheme
123456789987654321 <graphic> 123456789987654321
3/4 <graphic> 3/4
2.718281828 <graphic> 2.718281828
2.2+1.1i <graphic> 2.2+1.1i
```

Scheme数字包括精确和不精确的整数、有理数、实数和复数。精确整数和有理数具有任意精度，即它们可以是任意大小。不精确数通常使用IEEE标准浮点表示法在内部表示。

Scheme为相应的算术过程提供了名称`+`、`-`、`*`和`/`。每个过程接受两个数字参数。以下表达式称为过程应用，因为它们指定了将过程应用于一组参数。

```scheme
(+ 1/2 1/2) <graphic> 1
(- 1.5 1/2) <graphic> 1.0
(* 3 1/2) <graphic> 3/2
(/ 1.5 3/4) <graphic> 2.0
```

Scheme对常见算术操作也使用前缀表示法。任何过程应用，无论过程接受零个、一个、两个还是更多参数，都写为`(procedure arg ...)`。这种规律性简化了表达式的语法；无论操作如何，都使用一种表示法，并且没有关于运算符优先级或结合性的复杂规则。

过程应用可以嵌套，在这种情况下，最内层的值首先计算。因此，我们可以嵌套上述算术过程的应用来评估更复杂的公式。

```scheme
(+ (+ 2 2) (+ 2 2)) <graphic> 8
(- 2 (* 4 1/3)) <graphic> 2/3
(* 2 (* 2 (* 2 (* 2 2)))) <graphic> 32
(/ (* 6/7 7/2) (- 4.5 1.5)) <graphic> 1.0
```

这些示例展示了使用Scheme作为四功能桌面计算器所需的一切。虽然我们不会在本章讨论它们，但Scheme支持许多其他算术过程。现在可能是转到第6.4节并尝试其中一些的好时机。

简单的数字对象足以满足许多任务，但有时需要包含两个或多个值的聚合数据结构。在许多语言中，基本的聚合数据结构是数组。在Scheme中，它是列表。列表写为由对象组成的序列，用括号括起来。例如，`(1 2 3 4 5)`是一个数字列表，`("this" "is" "a" "list")`是一个字符串列表。列表不必只包含一种类型的对象，因此`(4.2 "hi")`是一个包含数字和字符串的有效列表。列表可以嵌套（可以包含其他列表），因此`((1 2) (3 4))`是一个具有两个元素的有效列表，每个元素都是一个包含两个元素的列表。

你可能会注意到列表看起来像过程应用，并想知道Scheme如何区分它们。也就是说，Scheme如何区分对象列表`(obj1 obj2 ...)`和过程应用`(procedure arg ...)`？

在某些情况下，区别可能看起来很明显。数字列表`(1 2 3 4 5)`几乎不可能与过程应用混淆，因为`1`是一个数字，而不是一个过程。因此，答案可能是Scheme查看列表或过程应用的第一个元素，并根据该第一个元素是否是过程做出决定。这个答案不够好，因为我们甚至可能希望将有效的过程应用如`(+ 3 4)`视为列表。答案是，我们必须明确告诉Scheme将列表视为数据而不是过程应用。我们使用`quote`来实现这一点。

```scheme
(quote (1 2 3 4 5)) <graphic> (1 2 3 4 5)
(quote ("this" "is" "a" "list")) <graphic> ("this" "is" "a" "list")
(quote (+ 3 4)) <graphme> (+ 3 4)
```

`quote`强制将列表视为数据。尝试输入上述表达式而不使用`quote`；你可能会收到一条消息，指示前两个表达式发生了异常，第三个表达式返回了错误的答案（7）。

由于`quote`在Scheme代码中经常使用，Scheme将表达式前的单引号（`'`）视为`quote`的缩写。

```scheme
'(1 2 3 4) <graphic> (1 2 3 4)
'((1 2) (3 4)) <graphic> ((1 2) (3 4))
'(/ (* 2 -1) 3) <graphic> (/ (* 2 -1) 3)
```

这两种形式都称为`quote`表达式。我们通常说一个对象在`quote`表达式中被引用。

`quote`表达式不是过程应用，因为它禁止对其子表达式求值。它是一种完全不同的语法形式。Scheme除了过程应用和`quote`表达式外，还支持其他几种语法形式。每种语法形式的求值方式不同。幸运的是，不同语法形式的数量很少。我们将在本章后面看到更多。

并非所有`quote`表达式都涉及列表。尝试以下表达式，带和不带`quote`包装。

```scheme
(quote hello) <graphic> hello
```

符号`hello`必须被引用，以防止Scheme将`hello`视为变量。Scheme中的符号和变量类似于数学表达式和方程中的符号和变量。当我们评估数学表达式`1 - x`时，我们将`x`视为变量。另一方面，当我们考虑代数方程`x² - 1 = (x - 1)(x + 1)`时，我们将`x`视为符号（实际上，我们将整个方程视为符号）。正如引用列表告诉Scheme将括号形式视为列表而不是过程应用一样，引用标识符告诉Scheme将标识符视为符号而不是变量。虽然符号通常用于表示方程或程序的符号表示中的变量，但符号也可以用于表示自然语言句子中的单词。

你可能会想知道为什么应用和变量与列表和符号共享表示法。共享表示法允许Scheme程序表示为Scheme数据，简化了在Scheme中编写解释器、编译器、编辑器和其他工具的过程。这在第12.7节中给出的Scheme解释器中得到了证明，该解释器本身是用Scheme编写的。许多人认为这是Scheme最重要的特性之一。

数字和字符串也可以被引用。

```scheme
'2 <graphic> 2
'2/3 <graphic> 2/3
(quote "Hi Mom!") <graphic> "Hi Mom!"
```

然而，数字和字符串在任何情况下都被视为常量，因此引用它们是不必要的。

现在让我们讨论一些用于操作列表的Scheme过程。有两个基本过程用于分解列表：`car`和`cdr`（发音为“could-er”）。`car`返回列表的第一个元素，`cdr`返回列表的其余部分。（名称“car”和“cdr”源自第一个实现Lisp语言的计算机IBM 704支持的操作。）每个过程都需要一个非空列表作为其参数。

```scheme
(car '(a b c)) <graphic> a
(cdr '(a b c)) <graphic> (b c)
(cdr '(a)) <graphic> ()
(car (cdr '(a b c))) <graphic> b
(cdr (cdr '(a b c))) <graphic> (c)
(car '((a b) (c d))) <graphic> (a b)
(cdr '((a b) (c d))) <graphic> ((c d))
```

列表的第一个元素通常称为列表的“car”，列表的其余部分通常称为列表的“cdr”。具有一个元素的列表的`cdr`是`()`，即空列表。

过程`cons`构造列表。它接受两个参数。第二个参数通常是一个列表，在这种情况下，`cons`返回一个列表。

```scheme
(cons 'a '()) <graphic> (a)
(cons 'a '(b c)) <graphic> (a b c)
(cons 'a (cons 'b (cons 'c '()))) <graphic> (a b c)
(cons '(a b) '(c d)) <graphic> ((a b) c d)
(car (cons 'a '(b c))) <graphic> a
(cdr (cons 'a '(b c))) <graphic> (b c)
(cons (car '(a b c))
      (cdr '(d e f))) <graphic> (a e f)
(cons (car '(a b c))
      (cdr '(a b c))) <graphic> (a b c)
```

正如“car”和“cdr”通常用作名词一样，“cons”通常用作动词。通过将元素添加到列表的开头来创建新列表称为将元素“cons”到列表中。

注意`cons`的第二个参数描述中的“通常”一词。过程`cons`实际上构建对，并且对的`cdr`不必是列表。列表是一系列对；每对的`cdr`是序列中的下一对。

```graphic
```

正确列表中的最后一对的`cdr`是空列表。否则，对序列形成一个不正确的列表。更正式地说，空列表是一个正确的列表，任何`cdr`是正确列表的对也是一个正确的列表。

不正确列表以点对表示法打印，点号（`.`）位于列表的最后一个元素之前。

```scheme
(cons 'a 'b) <graphic> (a . b)
(cdr '(a . b)) <graphic> b
(cons 'a '(b . c)) <graphic> (a b . c)
```

由于其打印表示法，`cdr`不是列表的对通常称为点对。即使`cdr`是列表的对也可以用点对表示法编写，尽管打印机总是选择不带点地编写正确列表。

```scheme
'(a . (b . (c . ()))) <graphic> (a b c)
```

过程`list`类似于`cons`，只是它接受任意数量的参数并始终构建一个正确列表。

```scheme
(list 'a 'b 'c) <graphic> (a b c)
(list 'a) <graphic> (a)
(list) <graphic> ()
```

第6.3节提供了更多关于列表和Scheme操作列表的过程的信息。现在可能是转到该部分并熟悉其中给出的其他过程的好时机。

#### 练习 2.2.1

将以下算术表达式转换为Scheme表达式并求值。

a. 1.2 × (2 - 1/3) + -8.7  
b. (2/3 + 4/9) ÷ (5/11 - 4/3)  
c. 1 + 1 ÷ (2 + 1 ÷ (1 + 1/2))  
d. 1 × -2 × 3 × -4 × 5 × -6 × 7  

#### 练习 2.2.2

尝试使用过程`+`、`-`、`*`和`/`来确定Scheme在给定不同类型数字参数时返回的值的类型规则。

#### 练习 2.2.3

确定以下表达式的值。使用你的Scheme系统验证你的答案。

a. `(cons 'car 'cdr)`  
b. `(list 'this '(is silly))`  
c. `(cons 'is '(this silly?))`  
d. `(quote (+ 2 3))`  
e. `(cons '+ '(2 3))`  
f. `(car '(+ 2 3))`  
g. `(cdr '(+ 2 3))`  
h. `cons`  
i. `(quote cons)`  
j. `(quote (quote cons))`  
k. `(car (quote (quote cons)))`  
l. `(+ 2 3)`  
m. `(+ '2 '3)`  
n. `(+ (car '(2 3)) (car (cdr '(2 3))))`  
o. `((car (list + - * /)) 2 3)`  

#### 练习 2.2.4

`(car (car '((a b) (c d))))`返回`a`。确定应用于`((a b) (c d))`的`car`和`cdr`的组合，返回`b`、`c`和`d`。

#### 练习 2.2.5

编写一个Scheme表达式，求值为以下内部列表结构。

```graphic
```

#### 练习 2.2.6

绘制以下表达式生成的内部列表结构。

```scheme
(cons 1 (cons '(2 . ((3) . ())) (cons '(()) (cons 4 5))))
```



练习 2.2.7

`(car (car (car '((a b) (c d)))))` 的行为是未定义的，因为 `(car '((a b) (c d)))` 是 `(a b)`，`(car '(a b))` 是 `a`，而 `(car 'a)` 是未定义的。请确定所有合法的 `car` 和 `cdr` 组合应用于 `((a b) (c d))` 的情况。

练习 2.2.8

尝试解释 Scheme 表达式是如何求值的。你的解释是否涵盖了练习 2.2.3 中的最后一个例子？

### 2.3 节：Scheme 表达式的求值

现在我们来讨论 Scheme 如何对你输入的表达式进行求值。我们已经为字符串和数字等常量对象建立了规则：对象本身就是其值。你可能已经在脑海中为形式为 `(procedure arg1 ... argn)` 的过程应用推导出了一个求值规则。在这里，`procedure` 是一个表示 Scheme 过程的表达式，`arg1 ... argn` 是表示其参数的表达式。一种可能性如下：

1. 找到 `procedure` 的值。
2. 找到 `arg1` 的值。
3. ...
4. 找到 `argn` 的值。
5. 将 `procedure` 的值应用于 `arg1 ... argn` 的值。

例如，考虑简单的过程应用 `(+ 3 4)`。`+` 的值是加法过程，`3` 的值是数字 `3`，`4` 的值是数字 `4`。将加法过程应用于 `3` 和 `4` 得到 `7`，所以我们的值是对象 `7`。

通过在每一层应用这个过程，我们可以找到嵌套表达式 `(* (+ 3 4) 2)` 的值。`*` 的值是乘法过程，`(+ 3 4)` 的值我们可以确定为数字 `7`，`2` 的值是数字 `2`。将 `7` 乘以 `2` 得到 `14`，所以我们的答案是 `14`。

这个规则适用于过程应用，但不适用于 `quote` 表达式，因为过程应用的子表达式会被求值，而 `quote` 表达式的子表达式不会。`quote` 表达式的求值更类似于常量对象的求值。形式为 `(quote object)` 的 `quote` 表达式的值就是 `object` 本身。

常量对象、过程应用和 `quote` 表达式只是 Scheme 提供的众多语法形式中的三种。幸运的是，Scheme 程序员只需要直接理解少数几种其他语法形式；这些被称为核心语法形式。其余的语法形式是语法扩展，最终由核心语法形式定义。我们将在本章的其余部分讨论其余的核心语法形式和少数语法扩展。3.1 节总结了核心语法形式并介绍了语法扩展机制。

在我们继续讨论更多语法形式和过程之前，关于过程应用求值的两点值得注意。首先，上述过程是过度指定的，因为它要求子表达式从左到右求值。也就是说，`procedure` 在 `arg1` 之前求值，`arg1` 在 `arg2` 之前求值，依此类推。这并不一定是必须的。Scheme 求值器可以自由地以任何顺序求值表达式——从左到右、从右到左或任何其他顺序。事实上，子表达式可以在不同的应用中以不同的顺序求值，甚至在同一实现中也是如此。

第二点是，`procedure` 的求值方式与 `arg1 ... argn` 相同。虽然 `procedure` 通常是一个命名特定过程的变量，但这并不一定是必须的。练习 2.2.3 要求你确定表达式 `((car (list + - * /)) 2 3)` 的值。在这里，`procedure` 是 `(car (list + - * /))`。`(car (list + - * /))` 的值是加法过程，就像 `procedure` 只是变量 `+` 一样。

练习 2.3.1

写下求值以下表达式所需的步骤。
`((car (cdr (list + - * /))) 17 5)`

### 2.4 节：变量和 Let 表达式

假设 `expr` 是一个包含变量 `var` 的 Scheme 表达式。此外，假设我们在求值 `expr` 时希望 `var` 的值为 `val`。例如，我们可能希望 `x` 的值为 `2` 时求值 `(+ x 3)`。或者，我们可能希望 `y` 的值为 `3` 时求值 `(+ 2 y)`。以下示例演示了如何使用 Scheme 的 `let` 语法形式来实现这一点。

```scheme
(let ((x 2))
  (+ x 3)) ; 5

(let ((y 3))
  (+ 2 y)) ; 5

(let ((x 2) (y 3))
  (+ x y)) ; 5
```

`let` 语法形式包括一个变量-表达式对的列表，以及一系列称为 `let` 主体的表达式。`let` 表达式的一般形式是：

```scheme
(let ((var expr) ...) body1 body2 ...)
```

我们说变量通过 `let` 绑定到值。我们将由 `let` 绑定的变量称为 `let` 绑定变量。

`let` 表达式通常用于简化包含两个相同子表达式的表达式。这样做还可以确保公共子表达式的值只计算一次。

```scheme
(+ (* 4 4) (* 4 4)) ; 32

(let ((a (* 4 4))) (+ a a)) ; 32
```

括号通常用于代替圆括号来分隔 `let` 表达式的绑定。

```scheme
(let ([list1 '(a b c)] [list2 '(d e f)])
  (cons (cons (car list1)
              (car list2))
        (cons (car (cdr list1))
              (car (cdr list2))))) ; ((a . d) b . e)
```

Scheme 将用方括号括起来的形式与用圆括号括起来的形式一样对待。开方括号必须与闭方括号匹配，开圆括号必须与闭圆括号匹配。我们使用方括号来表示 `let`（以及我们将看到的其他几种标准语法形式）以提高可读性，特别是当我们可能有两个或多个连续的开圆括号时。

由于过程应用第一位置的表达式与其他表达式的求值方式没有区别，`let` 绑定变量也可以在那里使用。

```scheme
(let ([f +])
  (f 2 3)) ; 5

(let ([f +] [x 2])
  (f x 3)) ; 5

(let ([f +] [x 2] [y 3])
  (f x y)) ; 5
```

由 `let` 绑定的变量仅在 `let` 的主体中可见。

```scheme
(let ([+ *])
  (+ 2 3)) ; 6

(+ 2 3) ; 5
```

这是幸运的，因为我们不希望 `+` 的值在任何地方都是乘法过程。

可以嵌套 `let` 表达式。

```scheme
(let ([a 4] [b -3])
  (let ([a-squared (* a a)]
        [b-squared (* b b)])
    (+ a-squared b-squared))) ; 25
```

当嵌套的 `let` 表达式绑定相同的变量时，只有内部 `let` 创建的绑定在其主体内可见。

```scheme
(let ([x 1])
  (let ([x (+ x 1)])
    (+ x x))) ; 4
```

外部的 `let` 表达式在其主体内将 `x` 绑定到 `1`，这是第二个 `let` 表达式。内部的 `let` 表达式在其主体内将 `x` 绑定到 `(+ x 1)`，这是表达式 `(+ x x)`。`(+ x 1)` 的值是多少？由于 `(+ x 1)` 出现在外部 `let` 的主体中，但不在内部 `let` 的主体中，`x` 的值必须是 `1`，因此 `(+ x 1)` 的值是 `2`。`(+ x x)` 呢？它出现在两个 `let` 表达式的主体中。只有内部绑定对 `x` 可见，所以 `x` 是 `2`，`(+ x x)` 是 `4`。

内部绑定对 `x` 被称为遮蔽了外部绑定。`let` 绑定变量在其 `let` 表达式的主体中随处可见，除了被遮蔽的地方。变量绑定可见的区域称为其作用域。上面示例中第一个 `x` 的作用域是外部 `let` 表达式的主体减去内部 `let` 表达式的主体，在那里它被第二个 `x` 遮蔽。这种作用域形式被称为词法作用域，因为每个绑定的作用域可以通过对程序进行简单的文本分析来确定。

通过为变量选择不同的名称可以避免遮蔽。上面的表达式可以重写，使内部 `let` 绑定的变量是 `new-x`。

```scheme
(let ([x 1])
  (let ([new-x (+ x 1)])
    (+ new-x new-x))) ; 4
```

尽管选择不同的名称有时可以防止混淆，但遮蔽可以帮助防止意外使用“旧”值。例如，在前面的示例的原始版本中，我们不可能在内部 `let` 的主体中错误地引用外部的 `x`。

练习 2.4.1

重写以下表达式，使用 `let` 去除公共子表达式并改进代码结构。不要进行任何代数简化。
  a.	`(+ (- (* 3 a) b) (+ (* 3 a) b))`
  b.	`(cons (car (list a b c)) (cdr (list a b c)))`

练习 2.4.2

确定以下表达式的值。解释你是如何推导出这个值的。
```scheme
(let ([x 9])
  (* x
     (let ([x (/ x 3)])
       (+ x x))))
```

练习 2.4.3

重写以下表达式，为每个不同的 `let` 绑定变量赋予唯一的名称，以便没有变量被遮蔽。验证你的表达式的值与原始表达式的值相同。
  a.	
```scheme
(let ([x 'a] [y 'b])
  (list (let ([x 'c]) (cons x y))
        (let ([y 'd]) (cons x y))))
```

  b.	
```scheme
(let ([x '((a b) c)])
  (cons (let ([x (cdr x)])
          (car x))
        (let ([x (car x)])
          (cons (let ([x (cdr x)])
                  (car x))
                (cons (let ([x (car x)])
                        x)
                      (cdr x))))))
```
